import spotipy
from spotipy.oauth2 import SpotifyOAuth
import pandas as pd
import json
import time
from pathlib import Path
import os
import re

# ==========================================================
# CONFIG
# ==========================================================
SCOPE = "playlist-modify-public playlist-modify-private library-read user-library-read"
CACHE_PATH = ".spotify_cache"

class SpotifyManager:
    def __init__(self):
        client_id = os.getenv("SPOTIPY_CLIENT_ID")
        client_secret = os.getenv("SPOTIPY_CLIENT_SECRET")
        redirect_uri = os.getenv("SPOTIPY_REDIRECT_URI", "http://127.0.0.1:8888/callback")
        
        if not client_id or not client_secret:
            raise ValueError("âŒ Missing SPOTIPY_CLIENT_ID or SPOTIPY_CLIENT_SECRET env vars.")

        self.sp = spotipy.Spotify(auth_manager=SpotifyOAuth(
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri,
            scope=SCOPE,
            cache_path=CACHE_PATH,
            open_browser=True
        ))
        
        self.user_id = self.sp.current_user()["id"]
        print(f"âœ… Authenticated as: {self.user_id}")
        self.track_cache = {}

    # ------------------------------------
    # SEARCH HELPER
    # ------------------------------------
    def search_track(self, name, artist):
        query = f"track:{name} artist:{artist}"
        cache_key = query.lower()
        if cache_key in self.track_cache:
            return self.track_cache[cache_key]

        try:
            results = self.sp.search(q=query, type="track", limit=1)
            items = results["tracks"]["items"]
            if items:
                uri = items[0]["uri"]
                self.track_cache[cache_key] = uri
                return uri
        except Exception as e:
            print(f"âš ï¸ Search error for '{query}': {e}")
        
        self.track_cache[cache_key] = None
        return None

    # ------------------------------------
    # PLAYLIST MANAGEMENT
    # ------------------------------------
    def get_or_create_playlist(self, name):
        """Finds existing playlist by name or creates a new one."""
        existing = self.sp.current_user_playlists(limit=50)
        # Paging could be needed for users with >50 playlists, simple version here
        for p in existing["items"]:
            if p["name"] == name:
                return p["id"]
        
        # Create
        print(f"ğŸ†• Creating playlist: {name}")
        p = self.sp.user_playlist_create(self.user_id, name, public=False, description="Generated by music-ML")
        return p["id"]

    def sync_csv_to_playlist(self, csv_path):
        """Reads a CSV playlist and mimics it on Spotify."""
        p_name = csv_path.stem.replace("_", " ").title() # e.g. "Electronic_Dance" -> "Electronic Dance"
        
        # Add "ML: " prefix to distinguish
        p_name = f"ML: {p_name}"
        
        print(f"\nğŸ“‚ Processing {csv_path.name} -> '{p_name}'...")
        df = pd.read_csv(csv_path)
        
        uris = []
        missing_count = 0
        
        for _, row in df.iterrows():
            name = row.get("Name", "")
            artist = row.get("Artist", "")
            
            if not isinstance(name, str) or not isinstance(artist, str):
                continue
                
            uri = self.search_track(name, artist)
            if uri:
                uris.append(uri)
            else:
                missing_count += 1
                # print(f"   âŒ Not found: {name} - {artist}") # verbose
        
        if not uris:
            print("   âš ï¸ No matching tracks found for this playlist.")
            return

        pid = self.get_or_create_playlist(p_name)
        
        # Replace contents (max 100 per request)
        # Strategy: PUT to replace all, or POST to add. 
        # replace_playlist_items is safest to 'sync' state.
        
        # Batching
        chunk_size = 100
        first_batch = True
        
        for i in range(0, len(uris), chunk_size):
            chunk = uris[i:i+chunk_size]
            if first_batch:
                self.sp.playlist_replace_items(pid, chunk)
                first_batch = False
            else:
                self.sp.playlist_add_items(pid, chunk)
                
        print(f"   âœ… Synced {len(uris)} tracks. ({missing_count} missing)")


    # ------------------------------------
    # BATCH RUNNER
    # ------------------------------------
    def run_all(self, playlists_dir="data/output/playlists"):
        p = Path(playlists_dir)
        if not p.exists():
            print(f"âŒ Directory not found: {p}")
            return
            
        csvs = list(p.glob("*.csv"))
        print(f"ğŸ” Found {len(csvs)} playlists to sync.")
        
        for csv in csvs:
            try:
                self.sync_csv_to_playlist(csv)
                time.sleep(1) # rate limit politeness
            except Exception as e:
                print(f"ğŸ”¥ Error syncing {csv.name}: {e}")

if __name__ == "__main__":
    try:
        manager = SpotifyManager()
        manager.run_all()
    except ValueError as ve:
        print(ve)
        print("ğŸ’¡ Please set them in your environment variables.")
    except Exception as e:
        print(f"ğŸ”¥ Fatal error: {e}")
